{"meta":{"title":"宇~空间","subtitle":"","description":"","author":"宇","url":"http://blog1.anpengyu.top","root":"/"},"pages":[{"title":"文章分类","date":"2020-11-01T16:00:00.000Z","updated":"2022-08-11T03:07:36.303Z","comments":true,"path":"categories/index.html","permalink":"http://blog1.anpengyu.top/categories/index.html","excerpt":"","text":"","author":"79bk.cn"},{"title":"个人简介","date":"2020-11-02T16:00:00.000Z","updated":"2022-08-11T03:07:36.303Z","comments":true,"path":"about/index.html","permalink":"http://blog1.anpengyu.top/about/index.html","excerpt":"","text":"","author":"宇"},{"title":"友情链接","date":"2020-09-18T16:00:00.000Z","updated":"2022-08-11T03:07:36.325Z","comments":true,"path":"links/index.html","permalink":"http://blog1.anpengyu.top/links/index.html","excerpt":"","text":"","author":"79bk.cn"},{"title":"tags","date":"2020-09-19T08:19:22.000Z","updated":"2022-08-11T03:07:36.325Z","comments":true,"path":"tags/index.html","permalink":"http://blog1.anpengyu.top/tags/index.html","excerpt":"","text":"","author":"79bk.cn"}],"posts":[{"title":"Hello World","slug":"hello-world","date":"2022-08-11T03:07:36.298Z","updated":"2022-08-11T03:07:36.298Z","comments":true,"path":"2022/08/11/hello-world/","link":"","permalink":"http://blog1.anpengyu.top/2022/08/11/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new &quot;My New Post&quot; More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"Android-Binder机制","slug":"Android-Binder机制","date":"2021-03-04T07:25:00.000Z","updated":"2022-08-11T03:07:36.291Z","comments":true,"path":"2021/03/04/Android-Binder机制/","link":"","permalink":"http://blog1.anpengyu.top/2021/03/04/Android-Binder%E6%9C%BA%E5%88%B6/","excerpt":"","text":"binder是什么？ 进程间通信机制 一个驱动 Binder.java –&gt; 实现IBinder –&gt;跨进程能力 + 自己创建的进程：webview 视频播放、音乐、大图浏览、推送 + 系统服务：打电话、闹钟 多进程有点： + 内存—&gt;一个app所占用内存有限 adb shell - getprop dalvik.vm.heapsize + 风险隔离—&gt;每一个进程，都是单独的一个APP + 性能 小于共享内存，优于其他IPC进程间通信 + 安全—&gt;为每个APP分配UID，同时支持实名和匿名 进程间通信： 内存被操作系统划分成两块：用户空间和内核空间，用户空间是用户程序代码运行的地方，内核空间是内核代码运行的地方。为了安全，它们是隔离的，即使用户的程序崩溃了，内核也不受影响 传统IPC机制，拷贝两次IBinder机制，拷贝一次","categories":[{"name":"Android","slug":"Android","permalink":"http://blog1.anpengyu.top/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://blog1.anpengyu.top/tags/Android/"}],"author":"宇"},{"title":"算法-高级排序-希尔排序","slug":"算法-希尔排序","date":"2021-03-04T06:38:00.000Z","updated":"2022-08-11T03:07:36.301Z","comments":true,"path":"2021/03/04/算法-希尔排序/","link":"","permalink":"http://blog1.anpengyu.top/2021/03/04/%E7%AE%97%E6%B3%95-%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/","excerpt":"","text":"希尔排序是插入排序的一种，又称“缩小增量排序”，是插入排序算法的一种更高效的改进版本。 选定一个增长量h，按照增长量h作为数据分组的依据，对数据进行分组。 对分好组的每一组数据完成插入排序 减小增长量，最小减为1，重复第二步操作 增长量h的确定： int h=1; while(h&lt;数组的长度/2)&#123; h=2h+1; &#125; //循环结束后我们就可以确定h的最大值； h的减小规则为： h=h/2 ```","categories":[{"name":"算法","slug":"算法","permalink":"http://blog1.anpengyu.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://blog1.anpengyu.top/tags/%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"排序","permalink":"http://blog1.anpengyu.top/tags/%E6%8E%92%E5%BA%8F/"}],"author":"宇"},{"title":"算法-插入排序","slug":"算法-插入排序","date":"2021-03-04T06:21:00.000Z","updated":"2022-08-11T03:07:36.301Z","comments":true,"path":"2021/03/04/算法-插入排序/","link":"","permalink":"http://blog1.anpengyu.top/2021/03/04/%E7%AE%97%E6%B3%95-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/","excerpt":"","text":"原理： 把所有元素分为两组，已经排序和未排序的 找到未排序组中的第一个元素，向已经排序的组中插入 倒叙便利已经排序的元素，依次和待插入的元素进行比较，直到找到一个元素小于等于待插入元素，那么就把待插入元素放到这个位置，其他的元素向后移动一位。 public class InsertionSort &#123; public static void srt(Comparable[] a) &#123; for (int i = 1; i &lt; a.length; i++) &#123; for(int j=i;j&gt;0;j--)&#123; //比较索引j处的值和索引j-1的值，如果索引j-1处的值大，则交换数据 if(greater(a[j-1],a[j]))&#123; exch(a,j-1,j); &#125;else&#123; break; &#125; &#125; &#125; &#125; //比较v元素是否大于w元素 private static boolean greater(Comparable v, Comparable w) &#123; return v.compareTo(w) &gt; 0; &#125; //数组元素i和j交换位置 private static void exch(Comparable[] a, int i, int j) &#123; Comparable temp; temp = a[i]; a[i] = a[j]; a[j] = temp; &#125; &#125; ``` 分析： 使用了双层for循环，其中内层循环的循环体是真正排序的代码，主要分析内层循环体的执行次数即可。 比较次数为： (N-1)+(N-2)+(N-3)+...+2+1=((N-1)+1)*(N-1)/2=N^2/2-N/2; 交换次数为： (N-1)+(n-2)+(N-3)+...+2+1=((N-1)+1)*(N-1)/2=N^2/2-N/2; 总执行次数为： (N^2/2-n/2)+(N^2/2-N/2)=N^2-N; 按照大O推导法则，保留函数中的最高阶项，时间复杂度为O(N^2)","categories":[{"name":"算法","slug":"算法","permalink":"http://blog1.anpengyu.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://blog1.anpengyu.top/tags/%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"排序","permalink":"http://blog1.anpengyu.top/tags/%E6%8E%92%E5%BA%8F/"}],"author":"宇"},{"title":"算法-选择排序","slug":"算法-选择排序","date":"2021-03-04T03:23:00.000Z","updated":"2022-08-11T03:07:36.302Z","comments":true,"path":"2021/03/04/算法-选择排序/","link":"","permalink":"http://blog1.anpengyu.top/2021/03/04/%E7%AE%97%E6%B3%95-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/","excerpt":"","text":"原理： 每一次遍历的过程中，都假定第一个索引处的元素是最小值，和其他索引处的值依次进行比较，如果当前索引处的值大于其他某个索引处的值，则假定其他某个索引处的值为最小值，最后可以找到最小值所在的索引。 交换第一个索引处和最小值所在的索引处的值 时间复杂度和冒泡排序一样 ```public class SelectSort { public static void srt(Comparable[] a) &#123; for (int i = 0; i &lt; a.length - 1; i++) &#123; int minIndex = i; for (int j = i + 1; j &lt; a.length; j++) &#123; //需要比较最小索引minIndex处的值和j索引处的值 if (greater(a[minIndex], a[j])) &#123; minIndex = j; &#125; &#125; //交换最小元素所在索引minIndex处的值和索引i处的值 exch(a,i,minIndex); &#125; &#125; //比较v元素是否大于w元素 private static boolean greater(Comparable v, Comparable w) &#123; return v.compareTo(w) &gt; 0; &#125; //数组元素i和j交换位置 private static void exch(Comparable[] a, int i, int j) &#123; Comparable temp; temp = a[i]; a[i] = a[j]; a[j] = temp; &#125; } ``` 双层for循环，外层循环完成了数据交换，内层循环完成了数据比较 数据比较次数：(N-1)+(N-2)+(N-3)+…+2+1=((N-1)+1)*(N-1)/2=N^2/2-N/2;数据交换次数：N-1 时间复杂度：N^2/2-N/2+(N-1)=N^2/2+N/2-1; 根据大O推到法则，保留最高阶项，去除常数因子，时间复杂度为O(N^2) 大O推导法则，保留最高阶项，去除常数因子","categories":[{"name":"算法","slug":"算法","permalink":"http://blog1.anpengyu.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://blog1.anpengyu.top/tags/%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"排序","permalink":"http://blog1.anpengyu.top/tags/%E6%8E%92%E5%BA%8F/"}],"author":"宇"},{"title":"算法-冒泡排序","slug":"算法-排序","date":"2021-03-04T01:21:00.000Z","updated":"2022-08-11T03:07:36.301Z","comments":true,"path":"2021/03/04/算法-排序/","link":"","permalink":"http://blog1.anpengyu.top/2021/03/04/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/","excerpt":"","text":"java提供了Comparable定义排序规则 Bubble Sort 原理： 比较相邻的两个元素。如果前一个元素比后一个元素大，就交换这两个元素的位置。 对每一对相邻的元素做同样的动作，从开始第一对元素到结尾的最后一对元素。最终最后一个元素就是最大值。 适用于排序元素较小，并且不是逆序的情况。如果是逆序，冒泡排序的时间复杂度太高。 //冒泡排序 public class Bubble &#123; //对数组a中的元素进行排序 public static void sort(Comparable[] a)&#123; for(int i=a.length-1;i&gt;0;i--)&#123; for(int j=0;j&lt;i;j++)&#123; if(greater(a[j],a[j+1]))&#123; exch(a,j,j+1); &#125; &#125; &#125; &#125; //比较v元素是否大于w元素 private static boolean greater(Comparable v,Comparable w)&#123; return v.compareTo(w)&gt;0; &#125; //数组元素i和j交换位置 private static void exch(Comparable[] a,int i,int j)&#123; Comparable temp; temp = a[i]; a[i] = a[j]; a[j] = temp; &#125; &#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://blog1.anpengyu.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://blog1.anpengyu.top/tags/%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"排序","permalink":"http://blog1.anpengyu.top/tags/%E6%8E%92%E5%BA%8F/"}],"author":"宇"},{"title":"数据结构","slug":"数据结构","date":"2021-03-02T09:11:05.000Z","updated":"2022-08-11T03:07:36.299Z","comments":true,"path":"2021/03/02/数据结构/","link":"","permalink":"http://blog1.anpengyu.top/2021/03/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","excerpt":"","text":"数据结构就是把数据元素按照一定的关系组合起来的集合，用来组合和存储数据。传统上，数据结构分为两大类：逻辑结构和物理结构。 逻辑结构是按照数据与数据之间的关系分类的，是抽象意义上的分类。 集合结构数据元素除了属于同一个集合外，他们之间没有任何其他关系 线性结构数据元素之间存在一对一的关系 树形结构数据元素之间存在一对多的层次关系 图形结构数据元素为多对多元素 物理结构是从计算机存储角度上进行分类是逻辑结构在计算机中真正的表现方式，又称为映像，也可以叫存储结构 顺序存储结构把数据元素放到地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的，比如我们常用的数组就是顺序存储结构弊端：如果中间有一环变化，整个结构都发生变化。 链式存储结构把数据结构存储在任意的存储单元里，这组存储单元可以是连续的也可以是不连续的。在链式存储结构中引进了指针存放数据元素地址，这样可以通过地址找到元素的位置 算法就是追求用最少的时间，占用最少的空间完成需求不同算法的体验，求1到100的和： public static void main ()&#123; int sum=0; int n =100; for(int i=0;i&lt;n;i++)&#123; sum+=i; &#125; &#125; public static void main1()&#123; int sum=0; int n=100; sum=(n+1)*n/2; &#125; 10的阶乘： public static long test(long n)&#123; if(n==1)&#123; return 1; &#125; return n*test(n-1); &#125; public static long test1(long n)&#123; int result = 1; for(long i=1;i&lt;n;i++)&#123; result*=i; &#125; return result; &#125; 算法中，对时间进行分析如何占用最少的时间称为时间复杂度分析对空间占用最少称为空间复杂度分析 算法分析： 算法采用的策略和方案 编译产生的代码方案 问题输入的规模（输入量是多少） 机器执行指令的的速度 分析一个算法的运行时间，最重要的就是把核心操作的次数和输入规模关联起来。 大O推导法则，保留最高阶项，去除常数因子","categories":[],"tags":[],"author":"宇"},{"title":"OkHttp","slug":"OkHttp","date":"2021-03-02T07:48:00.000Z","updated":"2022-08-11T03:07:36.296Z","comments":true,"path":"2021/03/02/OkHttp/","link":"","permalink":"http://blog1.anpengyu.top/2021/03/02/OkHttp/","excerpt":"","text":"Android 4.4开始HttpUrlConnection底层实现采用OkHttp。特点： 支持http2并允许对同一主机的所有请求共享一个套接字。 如果是非http2，则通过连接池，减少了请求延迟。Http是TCP协议，socket短连接，一次请求结束后则释放掉当前连接，每次调用接口都需要重新建立http连接。使用连接池会缓存http连接，快速响应。无需重复创建。 默认请求GZip压缩数据； 响应缓存，避免了重复请求的网络","categories":[{"name":"Android","slug":"Android","permalink":"http://blog1.anpengyu.top/categories/Android/"}],"tags":[],"author":"宇"},{"title":"设计模式-策略","slug":"设计模式-策略","date":"2021-03-02T02:21:00.000Z","updated":"2022-08-11T03:07:36.302Z","comments":true,"path":"2021/03/02/设计模式-策略/","link":"","permalink":"http://blog1.anpengyu.top/2021/03/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5/","excerpt":"","text":"该模式的优势在于，无论对任何事物进行排序，不需要修改最终排序方法，不用修改代码，只需要传入不同的排序策略即可。完美实现了开闭原则，对修改关闭，对扩展打开。 对一种事物进行排序 比如：长、宽、高等 不同的方式所排序的规则也不同 在不改变原有代码前提下随意切换任意一种排序策略 创建通用比较方法接口 @FunctionalInterface public interface Comparator&lt;T&gt; &#123; int compare(T o1,T o2); &#125; 创建排序（快速排序） public class Sorter&lt;T&gt; &#123; public void sort(T[] arr, Comparator&lt;T&gt; comparator) &#123; for (int i = 0; i &lt; arr.length - 1; i++) &#123; int minPos = i; for (int j = i + 1; j &lt; arr.length; j++) &#123; minPos = comparator.compare(arr[j], arr[minPos]) == -1 ? j :minPos; &#125; swap(arr, i, minPos); &#125; &#125; private void swap(T[] arr, int i, int minPos) &#123; T temp = arr[i]; arr[i] = arr[minPos]; arr[minPos] = temp; &#125; &#125; 实现Comparator接口，实现具体排序方法创建了两种实现类，其中compare具体的排序方式不同 public class CatHeightComparator implements Comparator&lt;Cat&gt;&#123; @Override public int compare(Cat o1, Cat o2) &#123; if(o1.height&gt;o2.height)&#123; return -1; &#125;else if(o1.height&lt;o2.height)&#123; return 1; &#125; return 0; &#125; &#125; 创建第二种策略 public class CatHeightComparator implements Comparator&lt;Cat&gt;&#123; @Override public int compare(Cat o1, Cat o2) &#123; if(o1.widget&lt;o2.widget)&#123; return -1; &#125;else if(o1.widget&lt;o2.widget)&#123; return 1; &#125; return 0; &#125; &#125; 传入不同的排序策略进行排序 Cat[] c1 = &#123;new Cat(1,1),new Cat(5,5),new Cat(3,3)&#125;; Sorter&lt;Cat&gt; sorter = new Sorter&lt;&gt;(); sorter.sort(c1,new CatHeightComparator()); sorter.sort(c1,new CatWeightComparator()); Log.e(&quot;策略模式&quot;, Arrays.toString(a));","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog1.anpengyu.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog1.anpengyu.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"author":"宇"},{"title":"设计模式-单例","slug":"设计模式","date":"2021-02-26T08:45:00.000Z","updated":"2022-08-11T03:07:36.302Z","comments":true,"path":"2021/02/26/设计模式/","link":"","permalink":"http://blog1.anpengyu.top/2021/02/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"单例设计模式 Singleton只需要有一个实例存在，比如各种Factory，各种Utils重点：私有化构造方法，外部不允许new该对象。 饿汉式特点：类加载到内存后，就实例一个对象，线程安全缺点：无论用到与否，类加载后都会实例对象。 public class SimpleSingle &#123; private static final String TAG = &quot;SimpleSingle&quot;; private static final SimpleSingle instance = new SimpleSingle(); private SimpleSingle()&#123;&#125; public static SimpleSingle getInstance()&#123; return instance; &#125; public void say(Context context)&#123; Toast.makeText(context,&quot;饿汉式单例&quot;,Toast.LENGTH_SHORT).show(); &#125;&#125; 懒汉式 特点：用到的时候才初始化实例缺点：无法保证对象唯一，线程不安全 public class LazySingle &#123; private static String TAG = &quot;SimpleSingle&quot;; private static LazySingle instance = null; private LazySingle() &#123; &#125; public static LazySingle getInstance() &#123; if (instance == null) &#123; instance = new LazySingle(); &#125; return instance; &#125; public void say(Context context) &#123; Toast.makeText(context, &quot;懒汉式单例&quot;, Toast.LENGTH_SHORT).show(); &#125;&#125; 双重锁由于懒汉式虽然达到了使用时才实例化的目的，但是线程不安全，所以在此基础上通过加锁保证线程安全，实例唯一缺点：繁琐注意：加上volatile，防止指令重排，会返回没有实例化的instance。 public class SafeSingle &#123; private static String TAG = &quot;SimpleSingle&quot;; private static volatile SafeSingle instance = null; private SafeSingle() &#123; &#125; public static SafeSingle getInstance() &#123; if (instance == null) &#123; synchronized (SafeSingle.class) &#123; if (instance == null) &#123; instance = new SafeSingle(); &#125; &#125; &#125; return instance; &#125; public void say(Context context) &#123; Toast.makeText(context, &quot;线程安全单例&quot;, Toast.LENGTH_SHORT).show(); &#125;&#125; 完美写法，内部类懒汉式+双重锁虽然保证线程安全，但是写法太繁琐，并且加载时判断过多内部类写法在饿汉式基础上改善，保证用到时加载实例，并且线程安全 public class InnerSingle &#123; private InnerSingle()&#123;&#125; private static class InnerSingleHolder&#123; private final static InnerSingle instance = new InnerSingle(); &#125; public static InnerSingle getInstance()&#123; return InnerSingleHolder.instance; &#125;&#125; 枚举单例最简单，即安全又”安全”，防止序列化java可以通过class文件将类加载到内存中new出来，枚举没有构造方法不会被反序列化， public enum EnumSingle &#123; INSTANCE; public void say()&#123; &#125; &#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog1.anpengyu.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog1.anpengyu.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"author":"宇"},{"title":"adb命令","slug":"adb命令","date":"2021-02-26T02:54:00.000Z","updated":"2022-08-11T03:07:36.296Z","comments":true,"path":"2021/02/26/adb命令/","link":"","permalink":"http://blog1.anpengyu.top/2021/02/26/adb%E5%91%BD%E4%BB%A4/","excerpt":"","text":"adb devices 查看连接设备adb install xxx.apk 安装应用adb install -r -d xxx.apk -r:强制安装 -d:安装低版本apk adb shell 挂载到手机设备 - getprop dalvik.vm.heapsize 一个进程所占用内存","categories":[],"tags":[{"name":"adb","slug":"adb","permalink":"http://blog1.anpengyu.top/tags/adb/"}],"author":"宇"},{"title":"Android-事件分发","slug":"Android-事件分发","date":"2021-02-22T08:57:00.000Z","updated":"2022-08-11T03:07:36.291Z","comments":true,"path":"2021/02/22/Android-事件分发/","link":"","permalink":"http://blog1.anpengyu.top/2021/02/22/Android-%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/","excerpt":"","text":"事件是如何传递的？ 事件冲突的原因 事件冲突的解决方法 Android的事件分发为从上往下分发1、事件类型：MotionEvent.ACTION_DOWN 按下，所有事件的开始MotionEvent.ACTION_UP 抬起MotionEvent.ACTION_MOVE 滑动MotionEvent.ACTION_CANCEL 被上层拦截事件列：从按下到抬起中发生的一系列事件 2、事件传递的对象Activity、ViewGroup、View以及View的派生类 分发过程：Activity-&gt;ViewGroup-&gt;ViewViewGroup：LinearLayout、RelativeLayout、GridLayout、FrameLayout、Toolbar、ListView、RecyclerVie.. 3、事件分发核心方法 dispatchTouchEvent() 分发事件onTouchEvent() 处理事件(View只处理事件，没有分发)onInterceptTouchEvent() 判断是否拦截事件，只存在ViewGroup中","categories":[{"name":"Android","slug":"Android","permalink":"http://blog1.anpengyu.top/categories/Android/"}],"tags":[{"name":"Android-基础","slug":"Android-基础","permalink":"http://blog1.anpengyu.top/tags/Android-%E5%9F%BA%E7%A1%80/"}],"author":"宇"},{"title":"Mysql-基础","slug":"Mysql-基础","date":"2021-02-20T08:41:40.000Z","updated":"2022-08-11T03:07:36.295Z","comments":true,"path":"2021/02/20/Mysql-基础/","link":"","permalink":"http://blog1.anpengyu.top/2021/02/20/Mysql-%E5%9F%BA%E7%A1%80/","excerpt":"","text":"分组获取数量SELECT s.photo_type,count(*) as count FROM photo s WHERE userid = ? group by s.photo_type;","categories":[],"tags":[],"author":"宇"},{"title":"Flutter-透明状态栏","slug":"Flutter-透明状态栏","date":"2021-02-18T05:40:29.000Z","updated":"2022-08-11T03:07:36.294Z","comments":true,"path":"2021/02/18/Flutter-透明状态栏/","link":"","permalink":"http://blog1.anpengyu.top/2021/02/18/Flutter-%E9%80%8F%E6%98%8E%E7%8A%B6%E6%80%81%E6%A0%8F/","excerpt":"","text":"sys_tools.dart class SysTools &#123; /// 设置状态栏为透明的 static setTransparentTitleBarColor() &#123; SystemUiOverlayStyle systemUiOverlayStyle = SystemUiOverlayStyle( statusBarColor: Colors.transparent, systemNavigationBarColor: Colors.black, ); SystemChrome.setSystemUIOverlayStyle(systemUiOverlayStyle); // //强制竖屏 // SystemChrome.setPreferredOrientations( // [DeviceOrientation.landscapeLeft, DeviceOrientation.landscapeRight]); &#125;&#125; main.dart runApp(MyApp()))SysTools.setTransparentTitleBarColor();","categories":[],"tags":[],"author":"宇"},{"title":"Flutter-package","slug":"Flutter-package","date":"2021-02-18T02:42:00.000Z","updated":"2022-08-11T03:07:36.293Z","comments":true,"path":"2021/02/18/Flutter-package/","link":"","permalink":"http://blog1.anpengyu.top/2021/02/18/Flutter-package/","excerpt":"","text":"1.路由管理、中间件、状态管理、动态路由、动画、返回值、懒加载flutter_modular 2.屏幕适配flutter_screenutil 3.日志logger 4.Toastfluttertoast 5.数据缓存shared_preferences 6.网络请求dio 7.组件老孟 8.二维码扫描qr_code_scanner","categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://blog1.anpengyu.top/categories/Flutter/"}],"tags":[{"name":"Flutter-基础","slug":"Flutter-基础","permalink":"http://blog1.anpengyu.top/tags/Flutter-%E5%9F%BA%E7%A1%80/"}],"author":"宇"},{"title":"Flutter-错误处理 List＜dynamic＞‘ is not a subtype of type ‘List＜xxx＞","slug":"Flutter-List＜dynamic＞‘-is-not-a-subtype-of-type-‘List＜DiskFile＞","date":"2021-01-21T02:16:00.000Z","updated":"2022-08-11T03:07:36.292Z","comments":true,"path":"2021/01/21/Flutter-List＜dynamic＞‘-is-not-a-subtype-of-type-‘List＜DiskFile＞/","link":"","permalink":"http://blog1.anpengyu.top/2021/01/21/Flutter-List%EF%BC%9Cdynamic%EF%BC%9E%E2%80%98-is-not-a-subtype-of-type-%E2%80%98List%EF%BC%9CDiskFile%EF%BC%9E/","excerpt":"","text":"错误：List＜dynamic＞‘ is not a subtype of type ‘List＜xxx＞ 错误代码：请求网络数据封装为model，返回List数据，方法返回类型为List&lt; AlbumModel&gt;，返回值也是List&lt; AlbumModel&gt;，接收数据为：var albumsArray = await PictureImpl.loadAlbums(context);流程没问题，接收的地方也没有限制，但是就是报错。 原因：Dart是一种可选的类型语言。Dart中的集合默认是异构的。换句话说，单个Dart集合可以托管各种类型的值。在res.map循环封装时，返回的结果类型其实是不确定的。而该函数的返回类型已经确定为List&lt; AlbumModel&gt;。因此返回结果类型不统一而报错。 解决在map循环时，指定封装的List泛型，泛型的使用强制限制集合可以包含的值的数据类型。这种集合称为类型安全集合。","categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://blog1.anpengyu.top/categories/Flutter/"},{"name":"Flutter-异常","slug":"Flutter/Flutter-异常","permalink":"http://blog1.anpengyu.top/categories/Flutter/Flutter-%E5%BC%82%E5%B8%B8/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://blog1.anpengyu.top/tags/Flutter/"}],"author":"宇"},{"title":"k8s 入门","slug":"k8s-入门","date":"2020-12-28T05:08:50.000Z","updated":"2022-08-11T03:07:36.299Z","comments":true,"path":"2020/12/28/k8s-入门/","link":"","permalink":"http://blog1.anpengyu.top/2020/12/28/k8s-%E5%85%A5%E9%97%A8/","excerpt":"","text":"安装k8s的四种方式： kubeadm 二进制 minikube yum minikube适合个人开发使用，二进制最适合生产环境，但是入手太难，kubeadm适合新手入门。 准备工作： 关闭防火墙system stop firewalld system disable firewalld 关闭selinux sed -i &#x27;s/enfocing/disabled/&#x27; /etc/selinux/config setenforce 0 关闭swap swapoff -a 暂时关闭vim /etc/fstab 添加主机名与IP对应关系 vi /etc/hosts 桥接IPv4流量传递到iptables的链 cat &gt; /etc/sysctl.d/k8s.conf &lt;&lt; EOFnet.bridge.bridge-nf-call-ip6tables = 1net.bridge.bridge-nf-call-iptables = 1EOFsysctl --system 所有节点安装Docker/kubeadm/kubeletkubenetes默认CRI（运行容器时）为Docker 安装Dockerhttps://anpengyu.github.io/2020/12/15/Docker-%E5%9F%BA%E7%A1%80/ 添加阿里云YUM软件源cat &gt; /etc/yum.repos.d/kubernetes.repo &lt;&lt; EOF[kubernetes]name=Kubernetesbaseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64enabled=1gpgcheck=0repo_gpgcheck=0gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpgEOF 安装kubeadm/kubelet/kubectl由于软件更新频繁，这里指定版本安装 yum install -y kubelet-1.15.0 kubeadm-1.15.0 kubectl-1.15.0systemctl enable kubelet 在master节点执行： kubeadm init \\--apiserver-advertise-address=192.168.12.168 \\--image-repository registry.aliyuncs.com/google_containers \\--kubernetes-version v1.15.0 \\--service-cidr=10.1.0.0/16 \\--pod-network-cidr=10.244.0.0/16 注意：安装时cpu必须2核以上，必须关闭swap 配置网络在kubeadm init执行完毕之后，需要配置网络信息 第一次执行kubectl get nodes可能会出现master节点状态为NotReady，需要配置kube-flannel.yml信息 kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/a70459be0084506e4ec919aa1c114638878db11b/Documentation/kube-flannel.yml 执行这一步时，如果没有梯子，会出现连接不上问题：The connection to the server raw.githubusercontent.com was refused - did you specify the right host or port?解决方法，查询IP获取raw.githubusercontent.com的真实ip地址，在hosts中添加域名关联 vi /etc/hosts 然后再次运行 kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/a70459be0084506e4ec919aa1c114638878db11b/Documentation/kube-flannel.yml 然后再执行kubectl get nodes，master节点已准备好 查询podskubectl get pods -n kube-system 添加node节点复制master节点初始化时生成的token 在node节点机器执行 node节点部署完成之后，在master节点查看状态 检查 aws-node 和 kube-proxy Pod 的状态kubectl get pods -n kube-system -o wide 删除节点kubectl delete pod coredns-bccdc95cf-bqtz6 coredns-bccdc95cf-p4klj -n kube-system 部署测试 部署一个nginx程序kubectl create deployment nginx --image=nginx 将端口暴露出去让外部访问kubectl expose deployment nginx --port=80 --type=NodePort 查看pod和servicekubectl get pod,svc","categories":[],"tags":[],"author":"宇"},{"title":"部署操作手册","slug":"部署操作手册","date":"2020-12-25T07:24:00.000Z","updated":"2022-08-11T03:07:36.302Z","comments":true,"path":"2020/12/25/部署操作手册/","link":"","permalink":"http://blog1.anpengyu.top/2020/12/25/%E9%83%A8%E7%BD%B2%E6%93%8D%E4%BD%9C%E6%89%8B%E5%86%8C/","excerpt":"","text":"使用k3s部署操作手册安装docker 安装k3s 安装helm 安装Lens(控制台)","categories":[{"name":"部署","slug":"部署","permalink":"http://blog1.anpengyu.top/categories/%E9%83%A8%E7%BD%B2/"}],"tags":[],"author":"宇"},{"title":"Lens","slug":"Lens","date":"2020-12-25T02:00:00.000Z","updated":"2022-08-11T03:07:36.295Z","comments":true,"path":"2020/12/25/Lens/","link":"","permalink":"http://blog1.anpengyu.top/2020/12/25/Lens/","excerpt":"","text":"k8s桌面客户端管理工具场景：从主机端管理服务器中的k8s从外部访问集群 安装lens MacOS：直接下载最新v3.5.0版本安装包 https://github.com/lensapp/lens/releases/download/v3.5.0/Lens-3.5.0.dmg Windows：直接下载v3.5.0版本安装包 https://github.com/lensapp/lens/releases/download/v3.5.0/Lens-Setup-3.5.0.exe Linux：访问安装文档 https://snapcraft.io/docs/installing-snapd，根据不同 Linux 版本安装不同程序 配置 从服务器中复制k3s.yaml文件 /etc/rancher/k3s/k3s.yaml 修改yaml中的ip为服务器ip 将服务器中拷贝的yaml内容粘贴到本机上 ~/.kube/config中 连接k8slens客户端中点击加号，选择自定义，将刚复制的yaml的内容粘贴进去，点击Add Cluster(s)然后就可以看到k8s相关操作","categories":[{"name":"部署","slug":"部署","permalink":"http://blog1.anpengyu.top/categories/%E9%83%A8%E7%BD%B2/"}],"tags":[{"name":"k3s","slug":"k3s","permalink":"http://blog1.anpengyu.top/tags/k3s/"},{"name":"k8s","slug":"k8s","permalink":"http://blog1.anpengyu.top/tags/k8s/"}],"author":"宇"},{"title":"Helm操作","slug":"Helm操作","date":"2020-12-24T06:40:00.000Z","updated":"2022-08-11T03:07:36.294Z","comments":true,"path":"2020/12/24/Helm操作/","link":"","permalink":"http://blog1.anpengyu.top/2020/12/24/Helm%E6%93%8D%E4%BD%9C/","excerpt":"","text":"环境：centos 8 概念helm是基于kubernetes的包管理器 chart创建一个应用的信息集合，包括各种kubernetes对象配置的模板、参数定义、依赖关系、文档说明等，可以将chart想象成yum中的软件安装包 release是chart的运行实例，代表一个正在运行的应用。当chart被安装到kubernetes集群，就会生成一个release，只会有一个release。 安装helm 下载wget https://get.helm.sh/helm-v3.1.0-linux-amd64.tar.gz 解压tar -zxvf helm-v3.1.0-linux-amd64.tar.gz 拷贝cp linux-amd64/helm /usr/local/bin 验证 添加chart源1. helm repo add stable https://kubernetes-charts.storage.googleapis.com2. helm repo add aliyuncs https://apphub.aliyuncs.com3. helm repo add cetic https://cetic.github.io/helm-charts 添加之后更新helm repo update查看chart源helm repo list查询某个库有哪些安装程序helm search repo aliyuncs | head -5查找安装程序helm search repo nginx 安装程序搜索helm search repo adminer安装helm install adminer cetic/adminer查看servicekubectl get svc -n defaultService(简称svc)定义了Pod的逻辑集合和访问该集合的策略，是真实服务的抽象删除一个应用helm uninstall nginx 问题解决 kubernetes cluster unreachableexport KUBECONFIG=/etc/rancher/k3s/k3s.yaml could not connect to server: Host is unreachable Is the server running on host “192.168.12.168” and accepting TCP/IP connections on port 5432?关闭服务器防火墙","categories":[{"name":"部署","slug":"部署","permalink":"http://blog1.anpengyu.top/categories/%E9%83%A8%E7%BD%B2/"},{"name":"k8s","slug":"部署/k8s","permalink":"http://blog1.anpengyu.top/categories/%E9%83%A8%E7%BD%B2/k8s/"}],"tags":[{"name":"部署","slug":"部署","permalink":"http://blog1.anpengyu.top/tags/%E9%83%A8%E7%BD%B2/"},{"name":"k3s","slug":"k3s","permalink":"http://blog1.anpengyu.top/tags/k3s/"},{"name":"k8s","slug":"k8s","permalink":"http://blog1.anpengyu.top/tags/k8s/"}],"author":"宇"},{"title":"centos 命令","slug":"centos-命令","date":"2020-12-23T09:43:00.000Z","updated":"2022-08-11T03:07:36.297Z","comments":true,"path":"2020/12/23/centos-命令/","link":"","permalink":"http://blog1.anpengyu.top/2020/12/23/centos-%E5%91%BD%E4%BB%A4/","excerpt":"","text":"查看内核版本uname -r 升级yum到最新sudo yum update 查看安装的软件列表yum list installed |grep xxx 删除软件yum -y remove xxx 安装软件yum -y install xxx -y:无需选择直接安装 安装yum-utils软件包（提供yum-config-manager 实用程序）并设置稳定的存储库。 防火墙 启动防火墙systemctl start firewalld.service 关闭防火墙systemctl stop firewalld.service 查看防火墙状态systemctl status firewalld 开机启动systemctl enable firewalld 不随开机启动systemctl disable firewalld pstree -g当前系统中正在运行的进程 $ sudo yum install -y yum-utils$ sudo yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo","categories":[{"name":"部署","slug":"部署","permalink":"http://blog1.anpengyu.top/categories/%E9%83%A8%E7%BD%B2/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://blog1.anpengyu.top/tags/linux/"},{"name":"centos","slug":"centos","permalink":"http://blog1.anpengyu.top/tags/centos/"},{"name":"命令","slug":"命令","permalink":"http://blog1.anpengyu.top/tags/%E5%91%BD%E4%BB%A4/"}],"author":"宇"},{"title":"k3s  安装","slug":"k3s-安装","date":"2020-12-23T05:46:00.000Z","updated":"2022-08-11T03:07:36.299Z","comments":true,"path":"2020/12/23/k3s-安装/","link":"","permalink":"http://blog1.anpengyu.top/2020/12/23/k3s-%E5%AE%89%E8%A3%85/","excerpt":"","text":"使用脚本安装curl -sfL http://rancher-mirror.cnrancher.com/k3s/k3s-install.sh | INSTALL_K3S_MIRROR=cn K3S_KUBECONFIG_MODE=&quot;644&quot; sh -关闭swapswapoff -a暂时关闭vi /etc/fstab一直关闭，编辑fstab，注释掉swap哪一行查看kubelet状态systemctl status kubelet","categories":[{"name":"部署","slug":"部署","permalink":"http://blog1.anpengyu.top/categories/%E9%83%A8%E7%BD%B2/"}],"tags":[{"name":"部署","slug":"部署","permalink":"http://blog1.anpengyu.top/tags/%E9%83%A8%E7%BD%B2/"},{"name":"k8s","slug":"k8s","permalink":"http://blog1.anpengyu.top/tags/k8s/"}],"author":"宇"},{"title":"eggjs搭建后台","slug":"eggjs搭建后台","date":"2020-12-15T09:08:00.000Z","updated":"2022-08-11T03:07:36.297Z","comments":true,"path":"2020/12/15/eggjs搭建后台/","link":"","permalink":"http://blog1.anpengyu.top/2020/12/15/eggjs%E6%90%AD%E5%BB%BA%E5%90%8E%E5%8F%B0/","excerpt":"","text":"","categories":[{"name":"Eggjs","slug":"Eggjs","permalink":"http://blog1.anpengyu.top/categories/Eggjs/"}],"tags":[{"name":"后台","slug":"后台","permalink":"http://blog1.anpengyu.top/tags/%E5%90%8E%E5%8F%B0/"},{"name":"nodejs","slug":"nodejs","permalink":"http://blog1.anpengyu.top/tags/nodejs/"},{"name":"eggjs","slug":"eggjs","permalink":"http://blog1.anpengyu.top/tags/eggjs/"}]},{"title":"React 基础","slug":"React-基础","date":"2020-12-15T09:07:37.000Z","updated":"2022-08-11T03:07:36.296Z","comments":true,"path":"2020/12/15/React-基础/","link":"","permalink":"http://blog1.anpengyu.top/2020/12/15/React-%E5%9F%BA%E7%A1%80/","excerpt":"","text":"","categories":[{"name":"React","slug":"React","permalink":"http://blog1.anpengyu.top/categories/React/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://blog1.anpengyu.top/tags/%E5%89%8D%E7%AB%AF/"},{"name":"React","slug":"React","permalink":"http://blog1.anpengyu.top/tags/React/"}]},{"title":"Android 组件","slug":"Android-组件","date":"2020-12-15T09:07:26.000Z","updated":"2022-08-11T03:07:36.291Z","comments":true,"path":"2020/12/15/Android-组件/","link":"","permalink":"http://blog1.anpengyu.top/2020/12/15/Android-%E7%BB%84%E4%BB%B6/","excerpt":"","text":"","categories":[{"name":"Android","slug":"Android","permalink":"http://blog1.anpengyu.top/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://blog1.anpengyu.top/tags/Android/"},{"name":"移动端","slug":"移动端","permalink":"http://blog1.anpengyu.top/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"}]},{"title":"Android 优化","slug":"Android-优化","date":"2020-12-15T09:07:07.000Z","updated":"2022-08-11T03:07:36.291Z","comments":true,"path":"2020/12/15/Android-优化/","link":"","permalink":"http://blog1.anpengyu.top/2020/12/15/Android-%E4%BC%98%E5%8C%96/","excerpt":"","text":"","categories":[{"name":"Android","slug":"Android","permalink":"http://blog1.anpengyu.top/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://blog1.anpengyu.top/tags/Android/"},{"name":"移动端","slug":"移动端","permalink":"http://blog1.anpengyu.top/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"}]},{"title":"Docker Dockerfile","slug":"Docker-Dockerfile","date":"2020-12-15T09:06:43.000Z","updated":"2022-08-11T03:07:36.292Z","comments":true,"path":"2020/12/15/Docker-Dockerfile/","link":"","permalink":"http://blog1.anpengyu.top/2020/12/15/Docker-Dockerfile/","excerpt":"","text":"","categories":[{"name":"Docker","slug":"Docker","permalink":"http://blog1.anpengyu.top/categories/Docker/"}],"tags":[{"name":"部署","slug":"部署","permalink":"http://blog1.anpengyu.top/tags/%E9%83%A8%E7%BD%B2/"},{"name":"Docker","slug":"Docker","permalink":"http://blog1.anpengyu.top/tags/Docker/"}]},{"title":"Flutter 基础","slug":"Flutter-基础","date":"2020-12-15T09:06:26.000Z","updated":"2022-08-11T03:07:36.293Z","comments":true,"path":"2020/12/15/Flutter-基础/","link":"","permalink":"http://blog1.anpengyu.top/2020/12/15/Flutter-%E5%9F%BA%E7%A1%80/","excerpt":"","text":"","categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://blog1.anpengyu.top/categories/Flutter/"}],"tags":[{"name":"移动端","slug":"移动端","permalink":"http://blog1.anpengyu.top/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"},{"name":"Flutter","slug":"Flutter","permalink":"http://blog1.anpengyu.top/tags/Flutter/"}]},{"title":"Graphql基础","slug":"graphql基础","date":"2020-12-15T09:06:26.000Z","updated":"2022-08-11T03:07:36.298Z","comments":true,"path":"2020/12/15/graphql基础/","link":"","permalink":"http://blog1.anpengyu.top/2020/12/15/graphql%E5%9F%BA%E7%A1%80/","excerpt":"","text":"","categories":[{"name":"Graphql","slug":"Graphql","permalink":"http://blog1.anpengyu.top/categories/Graphql/"}],"tags":[{"name":"Graphql","slug":"Graphql","permalink":"http://blog1.anpengyu.top/tags/Graphql/"}]},{"title":"Flutter 点击事件","slug":"Flutter-点击事件","date":"2020-12-15T09:06:07.000Z","updated":"2022-08-11T03:07:36.293Z","comments":true,"path":"2020/12/15/Flutter-点击事件/","link":"","permalink":"http://blog1.anpengyu.top/2020/12/15/Flutter-%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6/","excerpt":"","text":"","categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://blog1.anpengyu.top/categories/Flutter/"}],"tags":[{"name":"移动端","slug":"移动端","permalink":"http://blog1.anpengyu.top/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"},{"name":"Flutter","slug":"Flutter","permalink":"http://blog1.anpengyu.top/tags/Flutter/"}]},{"title":"Docker 基础","slug":"Docker-基础","date":"2020-12-15T09:06:00.000Z","updated":"2022-08-11T03:07:36.292Z","comments":true,"path":"2020/12/15/Docker-基础/","link":"","permalink":"http://blog1.anpengyu.top/2020/12/15/Docker-%E5%9F%BA%E7%A1%80/","excerpt":"","text":"基础命令 查看所有镜像docker images 查看容器docker ps正在运行的容器docker ps -a 所有容器 搜索镜像 docker search docker search nginx 删除 docker rm [容器id]|[容器名称] 删除容器 docker rmi [镜像id]|[镜像名:tag]删除镜像 docker命令 systemctl start docker启动docker systemctl restart docker sudo service docker restart systemctl stop docker service docker stop 关闭docker 容器启动日志 docker logs [容器id]|[容器名] 查看容器信息 docker inspect [容器id]|[容器名] dockerfile生成镜像 docker build --tag xxx . 启动容器 docker run -d --restart=always --name=nginx -p 80:80 nginx -t 为容器重新分配一个伪输入终端 -d 后台运行并返回容器id -i 以交互模式运行，通常与-t同时使用 –restart 重启策略，不指定restart时，docker启动后不会自动重启容器 always 容器退出时重启 on-failure 容器非正常退出时重启 on-failure:3 容器非正常退出时重启，最多重启3次 unless-stopped 容器退出时重启，但是Docker守护进程启动时就停止的容器不重启docker inspect -f &quot;&#123;&#123; .RestartCount &#125;&#125;&quot; nginx查看容器重启次数docker inspect -f &quot;&#123;&#123; .State.StartedAt &#125;&#125;&quot; nginx查看容器最后一次启动时间 –name 指定容器运行的名称 -p 端口映射，容器内部端口映射到主机的端口 –dns 指定容器使用的dns服务器，默认和宿主一致 –volume 挂载 -v /test:/soft容器目录挂载到宿主机目录，：前为宿主机目录 -e 环境变量 -e username=”xxx” 实例docker run -d --name nginx -p 80:80 nginx:latest使用nginx:latest镜像后台运行一个容器，容器名为nginx，映射ip为80docker run -d -p 80:80 -v /data:/data nginx:latest使用nginx:latest镜像运行一个后台容器，并挂载容器的data目录到宿主机的data目录docker run -it /bin/bash使用nginx:latest镜像前台运行容器，在容器内部执行/bin/bash命令 docker run -d \\ --name anpy-postgres \\ --network host \\ -p 5432:5432 \\ -e POSTGRES_USER=postgres \\ -e POSTGRES_PASSWORD=anpengyu \\ -e PGDATA=/var/lib/postgresql/data/pgdata \\ -v /home/anpy/anpy_pg_data:/var/lib/postgresql/data \\ postgres 进入容器内部docker exec -it id /bin/bash 查看安装的Docker版本yum list installed |grep docker 卸载dockeryum -y remove docker-ce.x86_64 sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine Docker安装（Centos 8）sudo yum install -y yum-utils sudo yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo sudo yum install docker-ce docker-ce-cli containerd.io 注意：centos8安装docker时会报podman和buildah冲突，可是删除后再安装docker yum remove podman-manpages.noarch 查看podman rpm -q podman 删除 dnf remove podmandnf remove buildah ##### 阿里云镜像加速 sudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;&#123; &quot;registry-mirrors&quot;: [&quot;https://70r39znu.mirror.aliyuncs.com&quot;]&#125;EOFsudo systemctl daemon-reloadsudo systemctl restart docker","categories":[{"name":"部署","slug":"部署","permalink":"http://blog1.anpengyu.top/categories/%E9%83%A8%E7%BD%B2/"}],"tags":[{"name":"部署","slug":"部署","permalink":"http://blog1.anpengyu.top/tags/%E9%83%A8%E7%BD%B2/"},{"name":"Docker","slug":"Docker","permalink":"http://blog1.anpengyu.top/tags/Docker/"}],"author":"anpy"},{"title":"Docker 搭建gitlab","slug":"Docker-搭建gitlab","date":"2020-12-15T09:06:00.000Z","updated":"2022-08-11T03:07:36.292Z","comments":true,"path":"2020/12/15/Docker-搭建gitlab/","link":"","permalink":"http://blog1.anpengyu.top/2020/12/15/Docker-%E6%90%AD%E5%BB%BAgitlab/","excerpt":"","text":"","categories":[{"name":"部署","slug":"部署","permalink":"http://blog1.anpengyu.top/categories/%E9%83%A8%E7%BD%B2/"}],"tags":[{"name":"部署","slug":"部署","permalink":"http://blog1.anpengyu.top/tags/%E9%83%A8%E7%BD%B2/"},{"name":"Docker","slug":"Docker","permalink":"http://blog1.anpengyu.top/tags/Docker/"}]},{"title":"Flutter与Android通信","slug":"Flutter与Android通信","date":"2020-12-15T09:05:50.000Z","updated":"2022-08-11T03:07:36.294Z","comments":true,"path":"2020/12/15/Flutter与Android通信/","link":"","permalink":"http://blog1.anpengyu.top/2020/12/15/Flutter%E4%B8%8EAndroid%E9%80%9A%E4%BF%A1/","excerpt":"","text":"","categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://blog1.anpengyu.top/categories/Flutter/"}],"tags":[{"name":"移动端","slug":"移动端","permalink":"http://blog1.anpengyu.top/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"},{"name":"Flutter","slug":"Flutter","permalink":"http://blog1.anpengyu.top/tags/Flutter/"}]},{"title":"网站收集","slug":"网站收集","date":"2020-12-15T09:00:59.000Z","updated":"2022-08-11T03:07:36.302Z","comments":true,"path":"2020/12/15/网站收集/","link":"","permalink":"http://blog1.anpengyu.top/2020/12/15/%E7%BD%91%E7%AB%99%E6%94%B6%E9%9B%86/","excerpt":"","text":"hexo官网 搭建个人博客 https://hexo.io/zh-cn/docs/","categories":[],"tags":[]},{"title":"hexo admin后台","slug":"hexo-admin后台","date":"2020-12-15T08:14:12.000Z","updated":"2022-08-11T03:07:36.298Z","comments":true,"path":"2020/12/15/hexo-admin后台/","link":"","permalink":"http://blog1.anpengyu.top/2020/12/15/hexo-admin%E5%90%8E%E5%8F%B0/","excerpt":"","text":"首先进入hexo创建的博客项目的根目录下，执行 npm install --save hexo-admin 运行 hexo s启动访问 localhost:4000/admin进入管理员界面 加入密码保护1、管理界面点击Settings，点击Setup authentification here 2、将生成的信息添加到_config.yml中 3、重启hexo，访问localhost:4000/admin就会看到输入密码界面","categories":[{"name":"hexo","slug":"hexo","permalink":"http://blog1.anpengyu.top/categories/hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://blog1.anpengyu.top/tags/Hexo/"}]},{"title":"hexo主题","slug":"hexo主题","date":"2020-12-15T08:14:12.000Z","updated":"2022-08-11T03:07:36.299Z","comments":true,"path":"2020/12/15/hexo主题/","link":"","permalink":"http://blog1.anpengyu.top/2020/12/15/hexo%E4%B8%BB%E9%A2%98/","excerpt":"","text":"转载：https://github.com/QiaoBug/hexo-theme-quiet 我们首先下载主题$ git clone https://github.com/QiaoBug/hexo-theme-quiet.git 然后我们修改Hexo根目录下的 _config.yml 文件启用 Quiet 主题： （大概在最后的位置 — 你需要将下载下来主题文件放在 themes里面并且将名字修改为 Quiet ） theme: Quiet 建议将每页展示的文章数量设置为 每页9篇 index_generator: path: &#x27;&#x27; per_page: 9 order_by: -date 将下面此项设置为跟我一样即可显示文章的代码高亮 我的配置highlight: enable: true line_number: false auto_detect: true tab_replace: &#x27;&#x27; wrap: true hljs: trueprismjs: enable: false preprocess: true line_number: true tab_replace: &#x27;&#x27; 🔧标签页进入根目录下的source文件夹下创建tag文件夹新建index.md文件 ---title: tagsdate: 2020-09-19 16:19:22layout: &quot;tags&quot;author: 79bk.cn--- 🏂简介页进入根目录下的source文件夹下创建about文件夹新建index.md文件 ---title: 个人简介date: 2020-11-03aubot: Cange-Qportrait: &#x27;https://cdn.jsdelivr.net/gh/duogongneng/MyBlogImg/imgIMG_7327.jpeg&#x27;describe: &#x27;一个阳光快乐的BOY,在正合适的年龄里希望遇见正好的你。&#x27;type: &quot;about&quot;layout: &quot;about&quot;author: 79bk.cn--- 解释 aubot ：博主名称显示在 About 页面的最上面 portrait ：头像 describe ：简介（简短的描述下你自己） 其他的不需要修改 内容 在简介页面你可以写很多的东西 你可以向写文章一样去写你的简介 你只需将内容写在 about文件夹下index.md文件里面 🎉友情链接进入根目录下的source文件夹下创建links文件夹新建index.md文件 ---title: 友情链接date: 2020-09-19type: &quot;links&quot;layout: &quot;links&quot;author: 79bk.cn--- 内容 你可能需要描述你的友情链接 那么你就需要将你想要描述的内容写在links文件夹下的index.md文件内 你会发现和 简介页 内容写法是一样的 🎪分类页进入根目录下的source文件夹下创建categories文件夹新建index.md文件 ---title: 文章分类date: 2020-11-02type: categorieslayout: categoriesauthor: 79bk.cn--- 📖发布文章你需要在发布文章的时候写标头 title: 一个简约扁平化的Hexo静态主题博客-Quietcategories: 项目案例tags: - Hexo - Quiet - 主题 - 静态主题excerpt: 采用简约大方的扁平化Hexo-Quiet主题date: 2020-11-03 20:33:36cover: &#x27;https://cdn.jsdelivr.net/gh/duogongneng/MyBlogImg/imgQuietView.png&#x27; 解释 title：文章标题 categories：分类（最好只写一个） tags：标签可以多个 excerpt：描述 date：创建日期 cover：缩略图（你不填就用默认的了） 🏆主题配置我们进入主题根目录下的themes文件夹下的Quiet文件里面的_config.yml配置文件 我们可以在里面 设置网站的标题,各种Logo图标 添加友情链接 在此配置文件中有个 linksList 我们可以仿照着去添加你的友情链接","categories":[{"name":"hexo","slug":"hexo","permalink":"http://blog1.anpengyu.top/categories/hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://blog1.anpengyu.top/tags/Hexo/"},{"name":"Quiet","slug":"Quiet","permalink":"http://blog1.anpengyu.top/tags/Quiet/"},{"name":"主题","slug":"主题","permalink":"http://blog1.anpengyu.top/tags/%E4%B8%BB%E9%A2%98/"},{"name":"静态主题","slug":"静态主题","permalink":"http://blog1.anpengyu.top/tags/%E9%9D%99%E6%80%81%E4%B8%BB%E9%A2%98/"}]},{"title":"hexo+github搭建个人博客","slug":"第一篇博客","date":"2020-12-15T06:52:00.000Z","updated":"2022-08-11T03:07:36.300Z","comments":true,"path":"2020/12/15/第一篇博客/","link":"","permalink":"http://blog1.anpengyu.top/2020/12/15/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/","excerpt":"采用简约大方的扁平化Hexo-Quiet主题","text":"1.软件安装1.1 下载并安装 node.js1.1.1 下载地址https://nodejs.org/en/ 1.1.2 安装后验证node -v 1.2 安装 cnpm1.2.1 安装命令npm install -g cnpm --registry==https://registry.npm.taobao.org 1.2.2 安装后验证 cnpmcnpm -v 1.3 安装 hexo1.3.1 安装命令cnpm install -g hexo-cli 1.3.2 安装后验证 hexohexo -v 2.使用 hexo 搭建 blog2.1 创建一个空白 dir, 并进入到该 dir, 比如zx-hexo 2.2 在 zx-hexo 目录下, 初始化 bloghexo init 2.3 本地启动 blog, 主要是本地预览文章用 (按下 ctrl+c 即可停止)hexo s 使用下述网址即可访问本地部署的 hexo 博客 http://localhost:4000 2.4 在 zx-hexo 目录下, 安装上传图片到 github 的插件cnpm install https://github.com/CodeFalling/hexo-asset-image --save 同时修改 zx-hexo 目录下, _config.yml文件配置 post_asset_folder:true 2.5 在 zx-hexo 目录下执行命令 ‘hexo n’新建一篇 blog, 进入该blog目录, 并用 md 工具比如(typora) 编辑该文章E:\\Programming\\zx-hexo&gt;hexo n “使用hexo搭建个人博客” INFO Created: E:\\Programming\\zx-hexo\\source_posts\\使用hexo搭建个人博客.md&gt;&gt; 可以发现该source目录下被新建了一个 文件及文件夹使用hexo搭建个人博客.md使用hexo搭建个人博客&gt;&gt; 在该文件中存放图片, 并在 md文件中引用即可&lt;img src=&quot;使用hexo搭建个人博客/xunlei.png&quot; style=&quot;zoom:50%;&quot; /&gt; 2.6 然后重新回到 zx-hexo 目录, 清理一下目录hexo clean 2.7 重新生成hexo g 2.8 再次重启, 预览即可看到hexo s 3.将 blog 部署到 github 个人主页上3.1 在 zx-hexo 目录下安装 hexo-deployer-gitcnpm install --save hexo-deployer-git 3.2 编辑 zx-hexo 目录下的 _config.yml 文件, 在文件末尾添加如下内容deploy: type: git repo: https://github.com/abc/abc.github.io.git branch: master 其中 repo 中的内容即为 github 个人主页链接地址, 关于如何创建 github 个人主页, 可自行百度即可 3.3 在 zx-hexo 目录下, 将本地 blog 推送到 git 仓, 可能需要输入 username &amp; pwdhexo d 3.4 推送成功后, 在浏览器中输入对应域名, 即可访问https://abc.github.io 4.更换主题4.1 假设要更换的主题是 maupassanthttps://www.haomwei.com/technology/maupassant-hexo.html 4.2 在 zx-hexo 目录下, 依次执行命令:git clone https://github.com/tufu9441/maupassant-hexo.git themes/maupassantcnpm install hexo-renderer-pug --savecnpm install hexo-renderer-sass --save 4.3 编辑 zx-hexo 目录下的 _config.yml 文件, 将theme的值改为maupassanttheme: maupassant 4.4 依次执行命令hexo cleanhexo g hexo d 4.5 再次在浏览器中输入对应域名, 即可发现主题已更换(可能会有几分钟延迟)https://abc.github.io","categories":[{"name":"hexo","slug":"hexo","permalink":"http://blog1.anpengyu.top/categories/hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://blog1.anpengyu.top/tags/Hexo/"},{"name":"Quiet","slug":"Quiet","permalink":"http://blog1.anpengyu.top/tags/Quiet/"},{"name":"主题","slug":"主题","permalink":"http://blog1.anpengyu.top/tags/%E4%B8%BB%E9%A2%98/"},{"name":"静态主题","slug":"静态主题","permalink":"http://blog1.anpengyu.top/tags/%E9%9D%99%E6%80%81%E4%B8%BB%E9%A2%98/"}],"author":"宇"}],"categories":[{"name":"Android","slug":"Android","permalink":"http://blog1.anpengyu.top/categories/Android/"},{"name":"算法","slug":"算法","permalink":"http://blog1.anpengyu.top/categories/%E7%AE%97%E6%B3%95/"},{"name":"设计模式","slug":"设计模式","permalink":"http://blog1.anpengyu.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"Flutter","slug":"Flutter","permalink":"http://blog1.anpengyu.top/categories/Flutter/"},{"name":"Flutter-异常","slug":"Flutter/Flutter-异常","permalink":"http://blog1.anpengyu.top/categories/Flutter/Flutter-%E5%BC%82%E5%B8%B8/"},{"name":"部署","slug":"部署","permalink":"http://blog1.anpengyu.top/categories/%E9%83%A8%E7%BD%B2/"},{"name":"k8s","slug":"部署/k8s","permalink":"http://blog1.anpengyu.top/categories/%E9%83%A8%E7%BD%B2/k8s/"},{"name":"Eggjs","slug":"Eggjs","permalink":"http://blog1.anpengyu.top/categories/Eggjs/"},{"name":"React","slug":"React","permalink":"http://blog1.anpengyu.top/categories/React/"},{"name":"Docker","slug":"Docker","permalink":"http://blog1.anpengyu.top/categories/Docker/"},{"name":"Graphql","slug":"Graphql","permalink":"http://blog1.anpengyu.top/categories/Graphql/"},{"name":"hexo","slug":"hexo","permalink":"http://blog1.anpengyu.top/categories/hexo/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://blog1.anpengyu.top/tags/Android/"},{"name":"算法","slug":"算法","permalink":"http://blog1.anpengyu.top/tags/%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"排序","permalink":"http://blog1.anpengyu.top/tags/%E6%8E%92%E5%BA%8F/"},{"name":"设计模式","slug":"设计模式","permalink":"http://blog1.anpengyu.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"adb","slug":"adb","permalink":"http://blog1.anpengyu.top/tags/adb/"},{"name":"Android-基础","slug":"Android-基础","permalink":"http://blog1.anpengyu.top/tags/Android-%E5%9F%BA%E7%A1%80/"},{"name":"Flutter-基础","slug":"Flutter-基础","permalink":"http://blog1.anpengyu.top/tags/Flutter-%E5%9F%BA%E7%A1%80/"},{"name":"Flutter","slug":"Flutter","permalink":"http://blog1.anpengyu.top/tags/Flutter/"},{"name":"k3s","slug":"k3s","permalink":"http://blog1.anpengyu.top/tags/k3s/"},{"name":"k8s","slug":"k8s","permalink":"http://blog1.anpengyu.top/tags/k8s/"},{"name":"部署","slug":"部署","permalink":"http://blog1.anpengyu.top/tags/%E9%83%A8%E7%BD%B2/"},{"name":"linux","slug":"linux","permalink":"http://blog1.anpengyu.top/tags/linux/"},{"name":"centos","slug":"centos","permalink":"http://blog1.anpengyu.top/tags/centos/"},{"name":"命令","slug":"命令","permalink":"http://blog1.anpengyu.top/tags/%E5%91%BD%E4%BB%A4/"},{"name":"后台","slug":"后台","permalink":"http://blog1.anpengyu.top/tags/%E5%90%8E%E5%8F%B0/"},{"name":"nodejs","slug":"nodejs","permalink":"http://blog1.anpengyu.top/tags/nodejs/"},{"name":"eggjs","slug":"eggjs","permalink":"http://blog1.anpengyu.top/tags/eggjs/"},{"name":"前端","slug":"前端","permalink":"http://blog1.anpengyu.top/tags/%E5%89%8D%E7%AB%AF/"},{"name":"React","slug":"React","permalink":"http://blog1.anpengyu.top/tags/React/"},{"name":"移动端","slug":"移动端","permalink":"http://blog1.anpengyu.top/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"},{"name":"Docker","slug":"Docker","permalink":"http://blog1.anpengyu.top/tags/Docker/"},{"name":"Graphql","slug":"Graphql","permalink":"http://blog1.anpengyu.top/tags/Graphql/"},{"name":"Hexo","slug":"Hexo","permalink":"http://blog1.anpengyu.top/tags/Hexo/"},{"name":"Quiet","slug":"Quiet","permalink":"http://blog1.anpengyu.top/tags/Quiet/"},{"name":"主题","slug":"主题","permalink":"http://blog1.anpengyu.top/tags/%E4%B8%BB%E9%A2%98/"},{"name":"静态主题","slug":"静态主题","permalink":"http://blog1.anpengyu.top/tags/%E9%9D%99%E6%80%81%E4%B8%BB%E9%A2%98/"}]}